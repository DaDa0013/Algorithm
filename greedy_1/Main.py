n = int(input())
D = [[0 for j in range(2)] for i in range(200001)]
for i in range(n):
	a, b = map(int, input().split())
	D[a][0] += 1 # 시작점
	D[b+1][1] += 1 # 끝점
a = 0
m = 0
for i in range(len(D)):
	a += D[i][0]
	a -= D[i][1]
	if m < a:
		m = a
print(m)

# 알고리즘 설명

# 이차원 리스트 D로 시작점을 a라 하고 끝 점을 b라 할 때, D[a][0]에 시작 점 갯수를 넣고 D[b+1][1]에 끝 점 갯수를 넣는다.
# 그 다음 for문으로 순차적으로 그 구간에서의 시작 점의 값을 더하고 끝 점을 빼서 최대 겹치는 갯수를 m에 저장한다.
# 이는 총 시작 점은 막대가 시작하는 것이므로 막대의 갯수라 생각하고, 끝 점에서 막대가 끝나기 때문에 막대의 갯수를 뺴는 것이다.
# 따라서 m으로 가장 막대가 많이 겹치는 구간에서의 막대 갯수를 저장하여 출력하는 것이다.

# 수행시간

# 먼저 이차원 리스트 D에 순차적으로 n개의 구간을 받으므로 O(n)에, 구간에서 최대로 겹치는 갯수를 구하기 위해 for문으로 n번 반복해야 하므로 O(n)이다.
# 따라서 최종 수행시간은 O(n)이다.