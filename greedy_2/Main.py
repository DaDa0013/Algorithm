n = int(input())
D=[[200002] for i in range(200002)]
for i in range(n):
	a, b = map(int, input().split())
	D[a].append(b)

m = 200001
ans = 0

for i in range(len(D)):
	if i > m:
		ans += 1
		m = min(D[i])
		continue
	if min(D[i]) < m: #최솟값
		m = min(D[i])

print(ans)

# 알고리즘 설명
# 먼저 이차원 리스트 D에 a와 b를 각각 시작점과 끝점이라 하였을 때 D[a]에 b를 넣어준다.
# 그 다음 끝 점의 최솟값을 계속 갱신하여 그 최솟값보다 시작점이 커질 때, 즉 최대로 겹치는 구간의 끝일 때 못의 갯수를 세어준다.
# 이는 막대가 최대로 겹칠 때 겹치는 막대들 중 가장 끝 점이 작은 것을 기준으로 잘라 못을 꽂는 것이다. 
# 그리고 끝 점의 최솟값이 시작 점보다 커졌을 때 그 앞에서 자르고, 다시 최솟값을 자른 곳으로 하여 계속 갱신하며 똑같이 반복한다.

# 수행시간
# 먼저 for문으로 n번 반복하여 이차원 리스트 D에 입력값을 받고, 다시 for문으로 리스트 D의 길이만큼 반복하여 끝 점의 최솟값을 갱신하고 시작 점과 비교하여 못의 갯수를 구한다.
# 따라서 총 수행시간은 O(n)이다.
